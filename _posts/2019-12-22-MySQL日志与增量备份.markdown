---
layout: post
title: "MySQL日志与增量备份"
data: 2019-12-22 18:56:00 +0800
author: "riki"
header-img: "img/postfm/1222.jpg"
tags:
- MySQL
typora-root-url: ...
---

> 未完待续...

[TOC]

#### MySQL日志的种类

MySQL的日志主要分为以下 6 种：

- Error log
- General query log
- Binary log
- Relay log
- Slow query log
- DDL log

我主要了解了下 Error log，General log，Slow query log 以及 Binary log。实际上，MySQL 的所有日志默认都是不开启的（除了错误日志），我们需要在 MySQL 服务启动时或者在运行时指定某些选项或者修改全局变量的值来开启这些日志。

##### Error Log

Error Log 用以记录 MySQL 服务启动或者关闭的时刻，除此之外它还会记录一些诊断信息：在服务启动，关闭或者运行中产生的警告，错误以及值得注意的信息，比如 MySQL 进行了自动的检查或者修复。此外，在某些操作系统上，在 MySQL 服务器程序异常退出的情况下，错误日志还会记录堆栈轨迹。

###### Error Log 的默认输出

通常，Error Log 文件会储存在 `/var/log/mysql/` 路径下。当然这其实也是由一个服务器选项的值决定的，这个值决定了默认的错误日志的输出方式，是输出到屏幕还是说输出到一个给定路径下的文件之中。

在这里我只了解Unix系统下的情况，`mysqld` 使用 `--log-error` 这个选项来决定错误日志的默认输出：

- 如果 `--log-error` 未指定，那么错误日志则输出到屏幕。
- 如果`--log-error` 指定，但是没有给出文件名，那么错误日志则会默认输出到 MySQL 数据目录下的 `hostname.err` 文件中。
- 如果该选项指定了一个文件，那么错误日志则会在 MySQL 数据目录下生成该文件记录错误信息，除非指定了一个不同数据目录的绝对路径。

###### Error Log 的过滤

Error Log 中往往会有着许多我们并不关心的信息，这些重复，高频出现的信息反而会干扰我们对问题的排查，所以需要有对某些信息进行过滤的功能，MySQL 提供两种形式的对 Error Log 进行过滤的方式：基于优先级的过滤和基于用户规则的过滤。这儿我只对基于优先级的过滤多说一点，因为它也是默认的方式。

基于优先级的过滤提供了一种简单的，根据错误事件的优先级以及错误代码来进行过滤。它有两种过滤模式：

- verbosity filtering

记录在错误日志中的事件都会有一个优先级：ERROR，WARNING，INFORMATION。这种过滤方式规定哪种优先级的信息可以被记录在错误日志文件中，以此来达到一个过滤的目的。它是由一个系统变量 `log_error_verbosity` 来控制的：1 代表只记录错误信息；2 代表记录错误信息和警告信息；3 代表所有信息都记录。

- supresssion-list filtering（v8.0)

这种过滤方式是通过隐藏某些事件来达到过滤的目的，当然它只能隐藏优先级为 WARING 或者 INFORMATION 的事件。比如说一个 WARNING 事件经常发生但是我们对它并不感兴趣，那么我们就可以隐藏它。

起到控制作用的环境变量则是 `log_error_supression_list`：如果为空则代表什么都不隐藏；如果是一个护着多个由逗号分隔的值，那么这些值代表的就是要被隐藏的错误代码。错误代码由符号形式和数字形式，通常来说，符号形式有着更好的可读性和兼容性。以下是一个例子：

```
ER_SERVER_SHUTDOWN_COMPLETE
MY-000031
000031
MY-31
31
```

v8.0)如果是数字代码，那么它可能有 `MY` 前缀，也可能没有；此外，数字部分的前缀 0 是没有意义的。

每一个指定的错误代码必须要是 MySQL 所使用的，否则的话会产生一个错误并且 `log_error_supression_list` 的值维持不变。



以上两种过滤方式是可以组合使用的。

至于基于用户规则的过滤方式，我没有去了解。

##### General query log

General query log 简单来说就是记录了 `mysqld` 到底做了什么的日志。客户端连接或者断开连接以及所有的来自客户端的 sql 语句它都会记录下来。当客户端发生了一个错误，而你想知道此时服务器到底做了什么的时候，这个日志就很有用。

关于这个日志的输出控制放在后面一起说。

##### Slow query log

慢查询日志会记录下所有执行所需花费时间超过某个值或者执行需要扫描的数据行超过某个值的 SQL 语句。这个日志可以帮助我们发现那些需要优化的 SQL 语句。

当然从冗长繁复的慢查询日志中去检查一个慢查询语句是一个非常耗时的工作，我们可以把它交给 `mysqldumpslow` 这个客户端工具，具体的使用方法我还没仔细看，后续再补充。

###### 慢查询控制变量

服务器根据以下几条来判断是否要将一条查询语句写入日志中：

1. 这条语句不能够是一条管理语句，管理语句是包含着这些元素的语句： ALTER TABLE，ANALYZE TABLE，CHECK TABLE，CREATE INDEX，DROP INDEX，OPTIMIZE TABLE 以及 REPAIR TABLE.。当然如果系统变量  `log_slow_admin_statements` 设置为允许，则这些语句也会被写入。
2. 这条语句执行所花费的时间至少为 long_query_time 秒，或者当系统变量  `log_queries_not_using_indexes` 设置为允许，并且这条查询语句没有用到索引。
3. 这条语句至少扫描了 `min_examined_row_limit` 行数据。
4. 这条语句不能被系统变量 `log_throttle_queries_not_using_indexes` 的设置而被隐藏。

此外，系统变量 `log_timestamp` 控制着写入慢查询日志记录的时间戳的时区。

###### 慢查询日志内容

写入日志的每个记录前面都有以 **#** 开始的一行，以及下方这些内容：

-  Query_time：语句执行的时间，单位是秒。

-  Lock_time：需要锁住的时间，单位是秒。

-  Rows_sent：发送到客户端的行数。

-  Rows_examined：服务器层检查的行数。


##### Binary log

二进制日志呢，是用来记录变化，它包含着诸如创建表，修改表中的数据的”事件“。以我目前所了解的，主要是用来进行数据的增量备份（incremental backup），更详细的我也没有再去了解。

#### MySQL 日志的输出

其实 MySQL 的日志不仅可以输出到指定文件中，其实它还可以写入到数据库表中，这些表是在 mysql 数据库中的，这里我们主要说的是如何去控制日志的输出位置以及相关的系统变量。

##### 如何控制

我们可以在 MySQL 服务器在启动时就指定日志的输出位置，也可以在服务器程序运行的过程中来改变日志的输出位置。

###### start up

在服务器程序启动时，我们可以指定系统变量 `log_output` 的值来规定日志的输出位置，我们可以指定的值有：FILE，TABLE，NONE，其含义正如其字面意思。这个值也可以是这三个的任意组合，即日志内容可以同时记录在文件中个表中。注意 NONE 的优先级高于其它两个，即只要指定了 NONE，就不会记录日志。

###### runtime

我们只要修改系统变量 `log_output` 的值就可以了。

##### 系统变量

- log_output：指定日志如何输出
- general_log：是否启用 general query log
- slow_query_log：是否启用慢查询日志
- general_log_file：指定 general log 输出文件名
- slow_query_log_file：指定慢查询日志文件名

##### 日志表的好处

1. 日志内容可以通过 SQL 语句来获得。
2. 当客户端和服务端不在同一个机器上的时候，日志的内容也可以在远端获得。
3. 默认情况下，日志表的储存引擎是 CSV，因此数据库数据目录下的 .CSV 文件可以很容易地就导入到其他项目中去。

#### MySQL 的备份

显而易见，对数据库的备份是非常重要的。无论是当发生了错误，例如软件崩溃，硬件损坏或者用户误删了数据，还有当我们升级数据库的时候，它能够帮助我们恢复数据并且重新的开始运行我们的数据库。

##### 不同种类的备份

备份根据其不同特征，可以被分为不同的种类：物理备份 vs. 逻辑备份，线上备份 vs. 离线备份，完全备份 vs. 增量备份...

###### 物理备份 vs. 逻辑备份

物理备份适用于比较大的，重要的数据库，这样的数据库需要能够较快的恢复速度，它有着以下的一些特征：

- 备份是由数据库目录或者文件所组成的，通常是这个数据库的数据目录的所有或者部分内容。
- 它比逻辑备份更快，因为它不需要转换。
- 它的输出更加的简明。
- 它的备份粒度范围上到整个数据库，下到单独的一个文件。因此呢它可能提供表级别的备份，也可能不提供，这取决于储存引擎。
- 备份还可以包含存在于数据库数据目录中的相关文件，包括日志文件或者配置文件。
- 物理备份只能在硬件非常相似的机器上兼容。
- 只有当 MySQL 服务器不在运行的时候，可以实施物理备份。

物理备份可以通过付费的项目 `mysqlbackup` 来备份 InnoDB 作为储存引擎的表或者任何其他的表。此外如果该表的储存引擎是 MyISAM 的话，可以通过文件系统层面的复制命令来进行备份（cp，scp...）。

恢复的话，只需要将复制的文件放到原始的路径下即可。

逻辑备份则有着以下的一些特征：

- 这种类型的备份是通过 SQL 语句来获得数据库的相关结构信息和数据的。
- 它比物理备份更慢，因为它需要访问数据库的信息，然后将其转换成为逻辑形式。
- 输出的信息比起物理备份来说更加的多。
- 从粒度上来说，它提供 3 个粒度的备份：server level，即所有的数据库都备份；database level，即所有的表都备份；table level。
- 它并不能备份相关联的日志文件或者配置文件。
- 相比于物理备份，它有着更好的兼容性。
- 它是在 MySQL 服务器运行的过程中实施的。

逻辑备份可以通过客户端程序 `mysqldump` 来备份，也可以通过 SQL 语句：`select ... into outfile` 来执行。相应的恢复可以使用客户端程序 `mysqlimport` 或者 SQL 语句：`load data` 来完成。

###### 线上备份 vs. 离线备份

线上备份对于其他用户来说有着更小的影响，因为在你备份的时候，其他用户也可以访问数据库中的数据，当然这还要看它们要执行是什么样的操作。线上备份最需要注意的是要用合适的锁以保证备份过程中不会有修改数据的事情发生从而破坏了备份的完整性。

线下备份的过程中，MySQL 服务器资源是不可获得的，为了减小该影响，通过该备份是通过复制从属服务器来完成的。此外线下备份的过程更为的简单，因为不存在因为客户活动而破坏备份完整性的可能。

从恢复上来说，线上恢复对客户的影响比线上备份的影响更大，这是由于线上备份时，只涉及到读取数据，其余的客户也还可以读取到数据，但是线上回复是需要修改数据，它需要更高级别的锁来防止其他的用户对这些待别修改的数据的访问。

###### 完全备份 vs. 增量备份

...

###### 备份方法

...