---
layout: post
title: "MySQL日志与增量备份"
data: 2019-12-22 18:56:00 +0800
author: "riki"
toc: true
header-img: "img/postfm/1222.jpg"
tags:
- MySQL
typora-root-url: ...
---

> 未完待续...

Table of Contents
=================

* [MySQL日志的种类](#mysql%E6%97%A5%E5%BF%97%E7%9A%84%E7%A7%8D%E7%B1%BB)
  * [Error Log](#error-log)
    * [Error Log 的默认输出](#error-log-%E7%9A%84%E9%BB%98%E8%AE%A4%E8%BE%93%E5%87%BA)
    * [Error Log 的过滤](#error-log-%E7%9A%84%E8%BF%87%E6%BB%A4)
  * [General query log](#general-query-log)
  * [Slow query log](#slow-query-log)
    * [慢查询控制变量](#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%8E%A7%E5%88%B6%E5%8F%98%E9%87%8F)
    * [慢查询日志内容](#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%86%85%E5%AE%B9)
  * [Binary log](#binary-log)
* [MySQL 日志的输出](#mysql-%E6%97%A5%E5%BF%97%E7%9A%84%E8%BE%93%E5%87%BA)
  * [如何控制](#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6)
    * [start up](#start-up)
    * [runtime](#runtime)
  * [系统变量](#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F)
  * [日志表的好处](#%E6%97%A5%E5%BF%97%E8%A1%A8%E7%9A%84%E5%A5%BD%E5%A4%84)
* [MySQL 的备份](#mysql-%E7%9A%84%E5%A4%87%E4%BB%BD)
  * [不同种类的备份](#%E4%B8%8D%E5%90%8C%E7%A7%8D%E7%B1%BB%E7%9A%84%E5%A4%87%E4%BB%BD)
    * [物理备份 vs\. 逻辑备份](#%E7%89%A9%E7%90%86%E5%A4%87%E4%BB%BD-vs-%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD)
    * [线上备份 vs\. 离线备份](#%E7%BA%BF%E4%B8%8A%E5%A4%87%E4%BB%BD-vs-%E7%A6%BB%E7%BA%BF%E5%A4%87%E4%BB%BD)
    * [完整备份 vs\. 增量备份](#%E5%AE%8C%E6%95%B4%E5%A4%87%E4%BB%BD-vs-%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD)
    * [备份策略总结](#%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93)
    * [备份方法](#%E5%A4%87%E4%BB%BD%E6%96%B9%E6%B3%95)

#### MySQL日志的种类

MySQL的日志主要分为以下 6 种：

- Error log
- General query log
- Binary log
- Relay log
- Slow query log
- DDL log

我主要了解了下 Error log，General log，Slow query log 以及 Binary log。实际上，MySQL 的所有日志默认都是不开启的（除了错误日志），我们需要在 MySQL 服务启动时或者在运行时指定某些选项或者修改全局变量的值来开启这些日志。

##### Error Log

Error Log 用以记录 MySQL 服务启动或者关闭的时刻，除此之外它还会记录一些诊断信息：在服务启动，关闭或者运行中产生的警告，错误以及值得注意的信息，比如 MySQL 进行了自动的检查或者修复。此外，在某些操作系统上，在 MySQL 服务器程序异常退出的情况下，错误日志还会记录堆栈轨迹。

###### Error Log 的默认输出

通常，Error Log 文件会储存在 `/var/log/mysql/` 路径下。当然这其实也是由一个服务器选项的值决定的，这个值决定了默认的错误日志的输出方式，是输出到屏幕还是说输出到一个给定路径下的文件之中。

在这里我只了解Unix系统下的情况，`mysqld` 使用 `--log-error` 这个选项来决定错误日志的默认输出：

- 如果 `--log-error` 未指定，那么错误日志则输出到屏幕。
- 如果`--log-error` 指定，但是没有给出文件名，那么错误日志则会默认输出到 MySQL 数据目录下的 `hostname.err` 文件中。
- 如果该选项指定了一个文件，那么错误日志则会在 MySQL 数据目录下生成该文件记录错误信息，除非指定了一个不同数据目录的绝对路径。

###### Error Log 的过滤

Error Log 中往往会有着许多我们并不关心的信息，这些重复，高频出现的信息反而会干扰我们对问题的排查，所以需要有对某些信息进行过滤的功能，MySQL 提供两种形式的对 Error Log 进行过滤的方式：基于优先级的过滤和基于用户规则的过滤。这儿我只对基于优先级的过滤多说一点，因为它也是默认的方式。

基于优先级的过滤提供了一种简单的，根据错误事件的优先级以及错误代码来进行过滤。它有两种过滤模式：

- verbosity filtering

记录在错误日志中的事件都会有一个优先级：ERROR，WARNING，INFORMATION。这种过滤方式规定哪种优先级的信息可以被记录在错误日志文件中，以此来达到一个过滤的目的。它是由一个系统变量 `log_error_verbosity` 来控制的：1 代表只记录错误信息；2 代表记录错误信息和警告信息；3 代表所有信息都记录。

- supresssion-list filtering（v8.0)

这种过滤方式是通过隐藏某些事件来达到过滤的目的，当然它只能隐藏优先级为 WARING 或者 INFORMATION 的事件。比如说一个 WARNING 事件经常发生但是我们对它并不感兴趣，那么我们就可以隐藏它。

起到控制作用的环境变量则是 `log_error_supression_list`：如果为空则代表什么都不隐藏；如果是一个护着多个由逗号分隔的值，那么这些值代表的就是要被隐藏的错误代码。错误代码由符号形式和数字形式，通常来说，符号形式有着更好的可读性和兼容性。以下是一个例子：

```
ER_SERVER_SHUTDOWN_COMPLETE
MY-000031
000031
MY-31
31
```

v8.0)如果是数字代码，那么它可能有 `MY` 前缀，也可能没有；此外，数字部分的前缀 0 是没有意义的。

每一个指定的错误代码必须要是 MySQL 所使用的，否则的话会产生一个错误并且 `log_error_supression_list` 的值维持不变。



以上两种过滤方式是可以组合使用的。

至于基于用户规则的过滤方式，我没有去了解。

##### General query log

General query log 简单来说就是记录了 `mysqld` 到底做了什么的日志。客户端连接或者断开连接以及所有的来自客户端的 sql 语句它都会记录下来。当客户端发生了一个错误，而你想知道此时服务器到底做了什么的时候，这个日志就很有用。

关于这个日志的输出控制放在后面一起说。

##### Slow query log

慢查询日志会记录下所有执行所需花费时间超过某个值或者执行需要扫描的数据行超过某个值的 SQL 语句。这个日志可以帮助我们发现那些需要优化的 SQL 语句。

当然从冗长繁复的慢查询日志中去检查一个慢查询语句是一个非常耗时的工作，我们可以把它交给 `mysqldumpslow` 这个客户端工具，具体的使用方法我还没仔细看，后续再补充。

###### 慢查询控制变量

服务器根据以下几条来判断是否要将一条查询语句写入日志中：

1. 这条语句不能够是一条管理语句，管理语句是包含着这些元素的语句： ALTER TABLE，ANALYZE TABLE，CHECK TABLE，CREATE INDEX，DROP INDEX，OPTIMIZE TABLE 以及 REPAIR TABLE.。当然如果系统变量  `log_slow_admin_statements` 设置为允许，则这些语句也会被写入。
2. 这条语句执行所花费的时间至少为 long_query_time 秒，或者当系统变量  `log_queries_not_using_indexes` 设置为允许，并且这条查询语句没有用到索引。
3. 这条语句至少扫描了 `min_examined_row_limit` 行数据。
4. 这条语句不能被系统变量 `log_throttle_queries_not_using_indexes` 的设置而被隐藏。

此外，系统变量 `log_timestamp` 控制着写入慢查询日志记录的时间戳的时区。

###### 慢查询日志内容

写入日志的每个记录前面都有以 **#** 开始的一行，以及下方这些内容：

-  Query_time：语句执行的时间，单位是秒。

-  Lock_time：需要锁住的时间，单位是秒。

-  Rows_sent：发送到客户端的行数。

-  Rows_examined：服务器层检查的行数。


##### Binary log

二进制日志呢，是用来记录变化，它包含着诸如创建表，修改表中的数据的”事件“。以我目前所了解的，主要是用来进行数据的增量备份（incremental backup），更详细的我也没有再去了解。

#### MySQL 日志的输出

其实 MySQL 的日志不仅可以输出到指定文件中，其实它还可以写入到数据库表中，这些表是在 mysql 数据库中的，这里我们主要说的是如何去控制日志的输出位置以及相关的系统变量。

##### 如何控制

我们可以在 MySQL 服务器在启动时就指定日志的输出位置，也可以在服务器程序运行的过程中来改变日志的输出位置。

###### start up

在服务器程序启动时，我们可以指定系统变量 `log_output` 的值来规定日志的输出位置，我们可以指定的值有：FILE，TABLE，NONE，其含义正如其字面意思。这个值也可以是这三个的任意组合，即日志内容可以同时记录在文件中个表中。注意 NONE 的优先级高于其它两个，即只要指定了 NONE，就不会记录日志。

###### runtime

我们只要修改系统变量 `log_output` 的值就可以了。

##### 系统变量

- log_output：指定日志如何输出
- general_log：是否启用 general query log
- slow_query_log：是否启用慢查询日志
- general_log_file：指定 general log 输出文件名
- slow_query_log_file：指定慢查询日志文件名

##### 日志表的好处

1. 日志内容可以通过 SQL 语句来获得。
2. 当客户端和服务端不在同一个机器上的时候，日志的内容也可以在远端获得。
3. 默认情况下，日志表的储存引擎是 CSV，因此数据库数据目录下的 .CSV 文件可以很容易地就导入到其他项目中去。

#### MySQL 的备份

显而易见，对数据库的备份是非常重要的。无论是当发生了错误，例如软件崩溃，硬件损坏或者用户误删了数据，还有当我们升级数据库的时候，它能够帮助我们恢复数据并且重新的开始运行我们的数据库。

##### 不同种类的备份

备份根据其不同特征，可以被分为不同的种类：物理备份 vs. 逻辑备份，线上备份 vs. 离线备份，完整备份 vs. 增量备份...

###### 物理备份 vs. 逻辑备份

物理备份适用于比较大的，重要的数据库，这样的数据库需要能够较快的恢复速度，它有着以下的一些特征：

- 备份是由数据库目录或者文件所组成的，通常是这个数据库的数据目录的所有或者部分内容。
- 它比逻辑备份更快，因为它不需要转换。
- 它的输出更加的简明。
- 它的备份粒度范围上到整个数据库，下到单独的一个文件。因此呢它可能提供表级别的备份，也可能不提供，这取决于储存引擎。
- 备份还可以包含存在于数据库数据目录中的相关文件，包括日志文件或者配置文件。
- 物理备份只能在硬件非常相似的机器上兼容。
- 只有当 MySQL 服务器不在运行的时候，可以实施物理备份。

物理备份可以通过付费的项目 `mysqlbackup` 来备份 InnoDB 作为储存引擎的表或者任何其他的表。此外如果该表的储存引擎是 MyISAM 的话，可以通过文件系统层面的复制命令来进行备份（cp，scp...）。

恢复的话，只需要将复制的文件放到原始的路径下即可。

逻辑备份则有着以下的一些特征：

- 这种类型的备份是通过 SQL 语句来获得数据库的相关结构信息和数据的。
- 它比物理备份更慢，因为它需要访问数据库的信息，然后将其转换成为逻辑形式。
- 输出的信息比起物理备份来说更加的多。
- 从粒度上来说，它提供 3 个粒度的备份：server level，即所有的数据库都备份；database level，即所有的表都备份；table level。
- 它并不能备份相关联的日志文件或者配置文件。
- 相比于物理备份，它有着更好的兼容性。
- 它是在 MySQL 服务器运行的过程中实施的。

逻辑备份可以通过客户端程序 `mysqldump` 来备份，也可以通过 SQL 语句：`select ... into outfile` 来执行。相应的恢复可以使用客户端程序 `mysqlimport` 或者 SQL 语句：`load data` 来完成。

###### 线上备份 vs. 离线备份

线上备份对于其他用户来说有着更小的影响，因为在你备份的时候，其他用户也可以访问数据库中的数据，当然这还要看它们要执行是什么样的操作。线上备份最需要注意的是要用合适的锁以保证备份过程中不会有修改数据的事情发生从而破坏了备份的完整性。

线下备份的过程中，MySQL 服务器资源是不可获得的，为了减小该影响，通过该备份是通过复制从属服务器来完成的。此外线下备份的过程更为的简单，因为不存在因为客户活动而破坏备份完整性的可能。

从恢复上来说，线上恢复对客户的影响比线上备份的影响更大，这是由于线上备份时，只涉及到读取数据，其余的客户也还可以读取到数据，但是线上回复是需要修改数据，它需要更高级别的锁来防止其他的用户对这些待别修改的数据的访问。

###### 完整备份 vs. 增量备份

一次完整备份是指在某个时间点，将 MySQL 服务器管理的所有数据都进行备份。增量备份则备份从某个时刻起的所有的数据变化。

定期执行完整备份是非常有必要而且有用的，但是处理完整备份并不是非常的方便，并且在有些场景下并不是最事宜的：每次连续的完整备份都包含着所有的数据，即使大部分的数据自从上次完整备份之后就再也没有改变过了。更有效率的一种方法是进行一次初始的完整备份，然后每次进行增量备份，增量备份花费更小并且所需时间更少。

为了实时增量备份，我们需要保存“变化”，在 MySQL 中，这些“变化”保存在二进制日志中，所以应打开该日志的使能开关。当服务器程序重启时，其都会创建一个新的二进制日志文件，当然在服务器运行时，我们也可以通过 `FLUSH LOGS` 来结束当前的二进制日志记录并且开启一个新的二进制日志。

那么我们如何通过二进制日志来进行数据恢复呢？通过一个例子来说明：

> 在星期天 13:00 我们完成一个完整备份，此时的新二进制日志我们假设文件名为 bichot2-bin.000007。
>
> 在星期一 13:00 我们通过刷新日志开启一个新的二进制日志 bichot2-bin.000008，同时星期天 13:00 到星期一 13:00 的所有“变化”都被储存在 bichot2-bin.000007 中。
>
> 在星期二 13:00 再次执行了增量备份的操作，所有的“变化”被储存在 bichot2-bin.000008 中。
>
> 假设星期三 08:00 机器崩溃了，那么我们需要对数据库进行恢复：首先恢复星期天 13:00 做的完整备份数据，在通过 mysqlbinlog 客户端工具 执行命令`mysqlbinlog gbichot2-bin.000007 gbichot2-bin.000008 | mysql` 来恢复直到星期二 13:00 的所有数据。如果我们的二进制日志不储存在数据库数据目录所存在的损坏的硬盘上，那么我们还可以获得星期二 13:00 到星期三 08:00 的所有“变化”，并且用上述的方法恢复过来。

###### 备份策略总结

- 打开二进制日志的使能开关，并且将其储存在与数据目录所在的驱动器不同的安全介质上。这么做的意外之喜是会提升性能表现（有利于硬盘的负载均衡）。
- 周期性地进行完整备份。
- 通过刷新日志周期性地进行增量备份。

###### 备份方法

备份的操作方法有多种，例如 mysqldump，文件系统中的复制命令以及通过 SQL 语句。

mysqldump 用来转存数据或者结构信息，对于数据量较小的情况比较适应，具体的使用方法可以查询官方文档。[mysqldump的使用方法](https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html)

对于储存引擎是 MyISAM 的数据表，可以通过复制命令，例如 cp 等来进行备份，数据目录中的 .MYD 文件代表数据，.MYI 代表的则是索引，以及相关的依赖文件 .sdi。

注意当数据库中含有以 InnoDB 作为储存引擎的表时，这种方法不起作用。

我们还可以通过 SQL 语句来进行数据备份，SQL 语句如下所示：

```sql
SELECT * INTO OUTFILE 'file_name' FROM tbl_nam
```

备份后生成的文件位于服务器所在的机器上的，并且这种方式只能保存表中的数据，并不能保存其结构。此外数据文件并不能是已经存在的文件，因为允许文件能够被重写存在着安全隐患。